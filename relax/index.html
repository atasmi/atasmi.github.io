<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>three.js â€¢ realistic galaxy â€¢ smooth gas â€¢ mouse flow</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .info {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 245, 240, 0.9);
            background: rgba(8, 6, 16, 0.4);
            backdrop-filter: blur(12px);
            padding: 12px 32px;
            border-radius: 60px;
            font-size: 15px;
            font-weight: 400;
            letter-spacing: 1.5px;
            border: 1px solid rgba(255, 220, 200, 0.2);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 100;
            pointer-events: none;
            white-space: nowrap;
            text-shadow: 0 2px 10px rgba(255,160,100,0.3);
        }
        .info span {
            color: #ffc8a2;
            margin-right: 8px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="info"><span>ðŸŒŒ</span> relax â€¢ made by flint@atomicmail.io</div>

    <!-- Import Three.js and add-ons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // --- setup scene with deep space color ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x03010a); // very dark purple-black
        
        // subtle fog for depth (helps blend distant stars)
        scene.fog = new THREE.FogExp2(0x03010a, 0.012);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 1.2, 9);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: false,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x03010a, 1);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.5;
        document.body.appendChild(renderer.domElement);

        // --- post-processing for soft bloom (adds realism and smoothness) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- lighting: subtle, to enhance depth ---
        const ambient = new THREE.AmbientLight(0x40406b);
        scene.add(ambient);
        
        // core light (will be positioned at center)
        const coreLight = new THREE.PointLight(0xffaa66, 2.0, 20, 1.5);
        coreLight.position.set(0, 0, 0);
        scene.add(coreLight);
        
        // fill light from below
        const fillLight = new THREE.PointLight(0x6688ff, 0.8, 15);
        fillLight.position.set(-2, -1, 2);
        scene.add(fillLight);

        // --- GALAXY CORE: realistic glowing sphere with soft halo ---
        // Main sphere
        const coreGeo = new THREE.SphereGeometry(0.65, 64, 64);
        const coreMat = new THREE.MeshStandardMaterial({
            color: 0xffaa77,
            emissive: 0xff5522,
            emissiveIntensity: 2.8,
            roughness: 0.2,
            metalness: 0.0
        });
        const core = new THREE.Mesh(coreGeo, coreMat);
        core.position.set(0, 0, 0);
        scene.add(core);

        // Soft glow sprite (for volumetric appearance)
        function createGlowSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Create a soft radial gradient
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 200, 160, 1)');
            gradient.addColorStop(0.2, 'rgba(220, 140, 140, 0.9)');
            gradient.addColorStop(0.4, 'rgba(160, 100, 200, 0.6)');
            gradient.addColorStop(0.6, 'rgba(80, 60, 180, 0.3)');
            gradient.addColorStop(0.8, 'rgba(30, 20, 80, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        const spriteMat = new THREE.SpriteMaterial({ 
            map: createGlowSprite(),
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });
        const glowSprite = new THREE.Sprite(spriteMat);
        glowSprite.scale.set(4.2, 4.2, 1);
        glowSprite.position.set(0, 0, 0);
        scene.add(glowSprite);

        // --- DUST PARTICLES: realistic, smooth, non-pixelated ---
        // We'll use multiple layers with varying sizes and blending modes
        
        // Layer 1: Dense inner disc (smaller particles, high density)
        const innerCount = 6000;
        const innerGeo = new THREE.BufferGeometry();
        const innerPos = new Float32Array(innerCount * 3);
        const innerCol = new Float32Array(innerCount * 3);
        
        for (let i = 0; i < innerCount; i++) {
            // Exponential distribution for density near center
            const r = Math.pow(Math.random(), 1.5) * 4.5 + 0.4;
            const angle = Math.random() * Math.PI * 2;
            // Spiral arm perturbation
            const armOffset = Math.floor(Math.random() * 3) * Math.PI * 2 / 3;
            const spiralAngle = r * 2.2 + armOffset + (Math.random() - 0.5) * 0.3;
            
            // Height - thin disc with slight warp
            const y = Math.sin(r * 2.5) * 0.3 + (Math.random() - 0.5) * 0.6;
            
            const x = Math.cos(spiralAngle) * r;
            const z = Math.sin(spiralAngle) * r;
            
            innerPos[i*3] = x;
            innerPos[i*3+1] = y;
            innerPos[i*3+2] = z;
            
            // Warm, golden to reddish hues
            const hue = 0.05 + (r * 0.1) + Math.random() * 0.1;
            const color = new THREE.Color().setHSL(hue, 0.9, 0.6);
            innerCol[i*3] = color.r;
            innerCol[i*3+1] = color.g;
            innerCol[i*3+2] = color.b;
        }
        
        innerGeo.setAttribute('position', new THREE.BufferAttribute(innerPos, 3));
        innerGeo.setAttribute('color', new THREE.BufferAttribute(innerCol, 3));
        
        const innerMat = new THREE.PointsMaterial({
            size: 0.04,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            sizeAttenuation: true,
            opacity: 0.9
        });
        
        const innerParticles = new THREE.Points(innerGeo, innerMat);
        scene.add(innerParticles);

        // Layer 2: Outer diffuse gas (larger, softer particles)
        const outerCount = 8000;
        const outerGeo = new THREE.BufferGeometry();
        const outerPos = new Float32Array(outerCount * 3);
        const outerCol = new Float32Array(outerCount * 3);
        
        for (let i = 0; i < outerCount; i++) {
            const r = Math.random() * 7.0 + 1.0;
            const angle = Math.random() * Math.PI * 2;
            // More random, less structured
            const spiralAngle = angle + Math.sin(r) * 2.0;
            const y = (Math.random() - 0.5) * 1.8;
            
            const x = Math.cos(spiralAngle) * r;
            const z = Math.sin(spiralAngle) * r;
            
            outerPos[i*3] = x;
            outerPos[i*3+1] = y;
            outerPos[i*3+2] = z;
            
            // Cooler, blue/purple tones for outer regions
            const hue = 0.7 + Math.random() * 0.3;
            const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
            outerCol[i*3] = color.r;
            outerCol[i*3+1] = color.g;
            outerCol[i*3+2] = color.b;
        }
        
        outerGeo.setAttribute('position', new THREE.BufferAttribute(outerPos, 3));
        outerGeo.setAttribute('color', new THREE.BufferAttribute(outerCol, 3));
        
        const outerMat = new THREE.PointsMaterial({
            size: 0.09,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            sizeAttenuation: true,
            opacity: 0.6,
            map: createSoftParticleTexture()
        });
        
        function createSoftParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        
        const outerParticles = new THREE.Points(outerGeo, outerMat);
        scene.add(outerParticles);

        // Layer 3: Very fine dust (extremely soft, almost nebula-like)
        const dustCount = 10000;
        const dustGeo = new THREE.BufferGeometry();
        const dustPos = new Float32Array(dustCount * 3);
        const dustCol = new Float32Array(dustCount * 3);
        
        for (let i = 0; i < dustCount; i++) {
            const r = Math.random() * 8.0 + 0.5;
            const angle = Math.random() * Math.PI * 2;
            const y = (Math.random() - 0.5) * 2.5;
            
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            
            dustPos[i*3] = x;
            dustPos[i*3+1] = y;
            dustPos[i*3+2] = z;
            
            // Mix of colors
            const hue = Math.random();
            const color = new THREE.Color().setHSL(hue, 0.6, 0.7);
            dustCol[i*3] = color.r;
            dustCol[i*3+1] = color.g;
            dustCol[i*3+2] = color.b;
        }
        
        dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
        dustGeo.setAttribute('color', new THREE.BufferAttribute(dustCol, 3));
        
        const dustMat = new THREE.PointsMaterial({
            size: 0.03,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            sizeAttenuation: true,
            opacity: 0.4,
            map: createSoftParticleTexture()
        });
        
        const dustParticles = new THREE.Points(dustGeo, dustMat);
        scene.add(dustParticles);

        // --- Background stars (distant, faint) ---
        const bgCount = 2000;
        const bgGeo = new THREE.BufferGeometry();
        const bgPos = new Float32Array(bgCount * 3);
        const bgCol = new Float32Array(bgCount * 3);
        
        for (let i = 0; i < bgCount; i++) {
            const r = 20 + Math.random() * 40;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta) * 0.3;
            const z = r * Math.cos(phi);
            
            bgPos[i*3] = x;
            bgPos[i*3+1] = y;
            bgPos[i*3+2] = z;
            
            const brightness = 0.2 + Math.random() * 0.5;
            bgCol[i*3] = brightness;
            bgCol[i*3+1] = brightness * 0.9;
            bgCol[i*3+2] = brightness;
        }
        
        bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
        bgGeo.setAttribute('color', new THREE.BufferAttribute(bgCol, 3));
        
        const bgMat = new THREE.PointsMaterial({
            size: 0.3,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            opacity: 0.5,
            map: createSoftParticleTexture()
        });
        
        const bgStars = new THREE.Points(bgGeo, bgMat);
        scene.add(bgStars);

        // --- Mouse interaction variables (smooth) ---
        const mouse = { x: 0, y: 0 };
        const targetRot = { x: 0, y: 0 };
        const currentRot = { x: 0, y: 0 };

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            targetRot.x = mouse.y * 0.25;
            targetRot.y = mouse.x * 0.4;
        });

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length) {
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                targetRot.x = mouse.y * 0.25;
                targetRot.y = mouse.x * 0.4;
            }
        });

        // --- Animation variables ---
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.005;

            // Smooth mouse interpolation
            currentRot.x += (targetRot.x - currentRot.x) * 0.03;
            currentRot.y += (targetRot.y - currentRot.y) * 0.03;

            // Rotate galaxy layers at different speeds for depth
            innerParticles.rotation.y += 0.00015;
            outerParticles.rotation.y += 0.00025;
            dustParticles.rotation.y += 0.00035;
            bgStars.rotation.y -= 0.00005;

            // Animate core pulse
            const pulse = 1.0 + Math.sin(time * 5) * 0.1;
            core.scale.setScalar(pulse);
            coreLight.intensity = 2.0 + Math.sin(time * 6) * 0.5;
            
            // Subtle color shift on outer particles (very slow)
            // Not doing per-particle to save performance

            // Camera movement based on mouse
            const targetCamX = Math.sin(currentRot.y) * 8.5;
            const targetCamY = currentRot.x * 1.8 + 1.0;
            const targetCamZ = Math.cos(currentRot.y) * 8.5;
            
            camera.position.x += (targetCamX - camera.position.x) * 0.02;
            camera.position.y += (targetCamY - camera.position.y) * 0.02;
            camera.position.z += (targetCamZ - camera.position.z) * 0.02;
            camera.lookAt(0, 0.2, 0);

            // Render via composer for bloom effect
            composer.render();
        }

        animate();

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Small initial nudge
        setTimeout(() => {
            mouse.x = 0.2;
            mouse.y = 0.1;
        }, 200);
    </script>
</body>
</html>
